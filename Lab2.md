# Lab 2

## Lincoln Samelson
## Collaborators: Brian Gaydon, Ali Hakimi, Chris Gray
## Principles of Programming: CSCI 3155

####Lab 2: Writeup

_1. Grammars: Synthetic Examples._

A ::= A & A | V

V ::= a | b

**Solutions**
**(a)**

               S1 is in AObjects S2 is in AObjects
            -----------------------------------------
                      S1 & S2 in AObjects
                      
                         S is in VObjects
                     ------------------------
                         S is in AObjects

**(b)**

				Because V => a or b, therefore:
						A => A & A
						A => (A & A) & (A & A)
						A => a & a & a & a
						
				This is ambiguous 
				
				Also:
						A => (A & A) & V
						A => (V & (A & A) & V)
						A => (a & (V & V) & a)
						A => (a & (a & a) & a)
						A => a & a & a & a
						
			    This too is ambiguous
			 
**(c)**

			L(S) = { a^n, b^n, c^n; n >= 0 }
			L(A) = { a^n; n >= 1  }
			L(B) = { b^m; m >= 0 }
			L(C) = { c^n; n >= 1  }
			
**(d)**


	1. baab
		
		   S ::= AaBb => baBb because A => b 
		              => baab because B => a
		   
		   baab is in the language
		   
	 
	    
	2. bbbab
	    

	       This grammar ensures all sentences contain more than one 'a' sequentially.
	       Since B => aB or a,  AND S ::= AaBb, the grammar S already contains a single 'a' 
	       S ::= AaBb => AbaBb since A => Ab
					  => AbbaBb 
					  => bbbaBb since A => b
					  => bbbaab since B => a
					  
		since   L(S) = { (b)^n(a)^m(b)^k; n >= 1  m > 1  k = 1 }
		        
		bbbab IS NOT IN the language 
		
		
	3. bbaaaaa
		
	       S ::= AaBb => AbaBb since A => Ab
					  => bbaBb since A => b
					  => bbaaBb since B => aB
					  => bbaaaBb => (b)^2(a)^5(b)^1 since B => aB or a
		
		   This grammar makes sure the string terminates in 'b' NOT 'a'. 
		   
		        L(S) = { (b)^n(a)^m(b)^k; n >= 1  m > 1  k = 1 }
		   
		   Therefore, bbaaaaa IS NOT IN the language generated by the
		   above grammar.
		 
		   
	4. bbaab
		
		S ::= AaBb => AbaBb since A => Ab | b
					    => bbaBb 
					    => bbaab since B => aB | a
		
		   baab IS IN the language
		   

			    
**(e)**

	1. abcd  - Is in the language
	
				S
			  /| |\
			 a S c B 
			   |   |
			   b   d
			    
	2. acccbd - Not in the langauge
	
				S
			  /| |\
			 a S c B
			   |   |
			   A   d
			  /|
			 c A
			   |
			   c

	3. acccbcc  - Not in the language
		
				S
			  /| |\
			 a S c B
			   |   |
			   A   A
			  /|   |\
			 c A   c A
			   |     |
			   c     c

		
		   
		
	4. acd - Not in the language
		
				S
			  /| |\
			 a S c B
			  /|   |
			 A b   d
			 |
			 c
		   
		   
		   
	5. accc - In the language
		   
				S
			  /| |\
			 a S c B
			   |   |
			   A   A
			   |   |
			   c   c
			   
		   
###2.

**(a)**
**Solutions**
	
	i. Intuitively describe the expressions generated by the two grammars:
		
		The expressions are essentially the same however, they are generated differently.    
		
		The language generated by both grammars is:
		
			L(e) = { (operand)^n (operator operand)^m; n = 1  m >= 0 }
					
		
	ii. Do these grammars generate the same or different expressions? Explain.
		
		These grammars generate the same expression but one uses left associativity and one uses
		right associativity.  That means they don't generate the same trees.  
						
		As shown below:
		
			e ::= operand | e operator operand:
			
						e
						|
				 ----------------------------------
				/		|		 \
			   e    operator     operand
			   |
			operand
			
					
			e ::= operand esuffix and esuffix ::= operator operand esuffix | epsilon:
			
			
						e
						|
				 ----------------
				/		| 		 \
			operand            esuffix
								  |
					       ----------------
						  /	 	  |  	   \
					operator    operand    esuffix
											  |
										   epsilon  



